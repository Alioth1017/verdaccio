/* eslint-disable no-console */
import http, { Agent } from 'http';
import https, { AgentOptions } from 'https';
import { pipeline } from 'stream';
import URL, { UrlWithStringQuery } from 'url';
import { promisify } from 'util';
import fs from 'fs';
import buildDebug from 'debug';

import { getNotFound, getInternalError, HTTP_STATUS, API_ERROR } from '@verdaccio/commons-api';
import { Config, Callback, Headers, Logger, Package, IReadTarball } from '@verdaccio/types';

import { fetch } from './fetch';

import { parseConfiguration } from './configuration';
import { prepareUrl, encodeScope, getRemoteMetadataUrl } from './utils';

export type RetryError = Error & {
  name: string;
  res: any;
};

export type OptsAsyncRetry = Retry & {
  maxRetryAfter?: number;
  retry: Retry;
};

export type AsyncRetry = OptsAsyncRetry & {
  onRetry: (error: RetryError, opts: OptsAsyncRetry) => void;
};

export type Retry = {
  retry?: number;
  factor?: number;
  minTimeout?: number;
  maxTimeout?: number;
  randomize?: boolean;
};

export type HttpsAgent = Pick<AgentOptions, 'rejectUnauthorized' | 'maxCachedSessions'>;
export type HttpAgent = Pick<Agent, 'maxSockets' | 'maxFreeSockets'>;

export interface ProxyAgent extends HttpAgent, HttpsAgent {}

export interface UpLinkTokenConf {
  type: 'Bearer' | 'Basic';
  token?: string;
  token_env?: boolean | string;
}

export type ProxyConfiguration = {
  maxage: string;
  timeout: string;
  max_fails: number;
  fail_timeout: string;
  strict_ssl: boolean;
  agent: any;
};

export interface UpLinkConf {
  url: string;
  ca?: string;
  cache?: boolean;
  timeout?: string | void;
  maxage?: string | void;
  max_fails?: number | void;
  fail_timeout?: string | void;
  headers?: Headers;
  auth?: UpLinkTokenConf;
  strict_ssl?: boolean | void;
  _autogenerated?: boolean;
}

export type UpLinkConfLocal = UpLinkConf & {
  no_proxy?: string;
};

export interface IProxy {
  config: UpLinkConfLocal;
  configProxy: ProxyConfiguration;
  failed_requests: number;
  userAgent: string;
  logger: Logger;
  server_id: string;
  url: any;
  maxage: number;
  timeout: number;
  max_fails: number;
  fail_timeout: number;
  upname: string;
  fetchTarball(url: string): IReadTarball;
  isUplinkValid(url: string): boolean;
  search(options: any);
  getRemoteMetadata(name: string, options: any, callback: Callback): void;
}

const streamPipeline = promisify(pipeline);

const httpAgent = new http.Agent({
  keepAlive: true,
});
const httpsAgent = new https.Agent({
  keepAlive: true,
});

function getAgent(protocol: string | null) {
  if (protocol == 'http:') {
    return httpAgent;
  } else {
    return httpsAgent;
  }
}

export type RemoteMetadata = {
  body: string;
  etag: string;
};

const debug = buildDebug('verdaccio:proxy');

class Proxy implements IProxy {
  private userAgent;
  private url: string;
  private agent: ProxyAgent;
  public constructor(config: UpLinkConfLocal) {
    if (!config) {
      throw Error('invalid proxy, config cannot be undefined');
    }

    this.url = prepareUrl(config.url);
    const urlParsed = URL.parse(this.url);
    debug('uplink %o', this.url);
    this.agent = getAgent(urlParsed.protocol);
  }

  private async streamRequest() {}

  public async search() {}
  // @ts-ignore
  public async fetchTarball(distTarball: string): Promise<ReadableStream> {
    const response = await fetch(distTarball);
    if (response.ok) {
      return response.body;
    }

    console.log('response', response);
    const { status } = response;
    if (status === HTTP_STATUS.NOT_FOUND) {
      throw getNotFound(API_ERROR.NOT_PACKAGE_UPLINK);
    }

    if (!(status >= HTTP_STATUS.OK && status < HTTP_STATUS.MULTIPLE_CHOICES)) {
      throw getInternalError(`${API_ERROR.BAD_STATUS_CODE}: ${response.status}`);
    }
  }

  public async getRemoteMetadata(packageName: string): Promise<RemoteMetadata | void> {
    const url = getRemoteMetadataUrl(this.url, packageName);
    const response = await fetch(url);
    if (response.ok) {
      const body: string = await response.json();
      const { headers } = response;
      return {
        body,
        etag: headers.get('etag'),
      };
    }

    const { status } = response;
    if (response.status === HTTP_STATUS.NOT_FOUND) {
      throw getNotFound(API_ERROR.NOT_PACKAGE_UPLINK);
    }
    if (!(status >= HTTP_STATUS.OK && status < HTTP_STATUS.MULTIPLE_CHOICES)) {
      throw getInternalError(`${API_ERROR.BAD_STATUS_CODE}: ${response.status}`);
    }
  }
}

export default Proxy;
