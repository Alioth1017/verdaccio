/* eslint-disable no-console */
import http, { Agent } from 'http';
import https, { AgentOptions } from 'https';
import { pipeline } from 'stream';
import URL, { UrlWithStringQuery } from 'url';
import { promisify } from 'util';
import fs from 'fs';

import { Config, Callback, Headers, Logger, Package, IReadTarball } from '@verdaccio/types';

import fetch from './fetch';

import { parseConfiguration } from './configuration';

export type RetryError = Error & {
  name: string;
  res: any;
};

export type OptsAsyncRetry = Retry & {
  maxRetryAfter?: number;
  retry: Retry;
};

export type AsyncRetry = OptsAsyncRetry & {
  onRetry: (error: RetryError, opts: OptsAsyncRetry) => void;
};

export type Retry = {
  retry?: number;
  factor?: number;
  minTimeout?: number;
  maxTimeout?: number;
  randomize?: boolean;
};

export type HttpsAgent = Pick<AgentOptions, 'rejectUnauthorized' | 'maxCachedSessions'>;
export type HttpAgent = Pick<Agent, 'maxSockets' | 'maxFreeSockets'>;

export interface ProxyAgent extends HttpAgent, HttpsAgent {}

export interface UpLinkTokenConf {
  type: 'Bearer' | 'Basic';
  token?: string;
  token_env?: boolean | string;
}

export type ProxyConfiguration = {
  maxage: string;
  timeout: string;
  max_fails: number;
  fail_timeout: string;
  strict_ssl: boolean;
  agent: any;
};

export interface UpLinkConf {
  url: string;
  ca?: string;
  cache?: boolean;
  timeout?: string | void;
  maxage?: string | void;
  max_fails?: number | void;
  fail_timeout?: string | void;
  headers?: Headers;
  auth?: UpLinkTokenConf;
  strict_ssl?: boolean | void;
  _autogenerated?: boolean;
}

export type UpLinkConfLocal = UpLinkConf & {
  no_proxy?: string;
};

export interface IProxy {
  config: UpLinkConfLocal;
  configProxy: ProxyConfiguration;
  failed_requests: number;
  userAgent: string;
  logger: Logger;
  server_id: string;
  url: any;
  maxage: number;
  timeout: number;
  max_fails: number;
  fail_timeout: number;
  upname: string;
  fetchTarball(url: string): IReadTarball;
  isUplinkValid(url: string): boolean;
  search(options: any);
  getRemoteMetadata(name: string, options: any, callback: Callback): void;
}

const streamPipeline = promisify(pipeline);

const httpAgent = new http.Agent({
  keepAlive: true,
});
const httpsAgent = new https.Agent({
  keepAlive: true,
});

function getAgent(protocol: string | null) {
  if (protocol == 'http:') {
    return httpAgent;
  } else {
    return httpsAgent;
  }
}

class Proxy implements IProxy {
  private userAgent;
  private url: UrlWithStringQuery;
  private agent: ProxyAgent;
  public constructor(config: UpLinkConfLocal) {
    this.url = URL.parse(config.url);
    this.agent = getAgent(this.url.protocol);
  }

  private async streamRequest() {}

  public async getRemoteMetadata(packageName: string): Promise<Package> {
    try {
      const response = await fetch();
      console.log('--response.ok', response.ok);
      if (response.ok) {
        await streamPipeline(response.body, null);
      } else {
        // throw error, mapped, 404
      }
    } catch (error) {}
  }
}

export default Proxy;
